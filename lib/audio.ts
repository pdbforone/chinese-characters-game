/**
 * Audio Playback Module
 *
 * Manages character pronunciation audio using Howler.js.
 * Respects user's sound preferences from localStorage.
 *
 * Features:
 * - Lazy loading (only loads audio when needed)
 * - Graceful fallbacks (if audio fails, app continues working)
 * - Privacy-first (all audio files bundled, no external requests)
 * - Accessibility (provides feedback via callbacks)
 */

import { Howl } from 'howler';

// Audio manifest (maps characters to filenames)
// This will be generated by scripts/generate-audio-edge.py
let audioManifest: Record<
  string,
  { filename: string; pinyin: string; tone: number; meaning: string }
> | null = null;

// Cache of loaded Howl instances
const audioCache = new Map<string, Howl>();

// Storage key for sound preferences (shared with existing sound toggle)
const SOUND_ENABLED_KEY = 'sound-enabled';

/**
 * Check if sound is enabled in user preferences
 */
export function isSoundEnabled(): boolean {
  if (typeof window === 'undefined') return false;

  try {
    const enabled = localStorage.getItem(SOUND_ENABLED_KEY);
    return enabled !== 'false'; // Default to true if not set
  } catch {
    return true; // Default to enabled if localStorage unavailable
  }
}

/**
 * Toggle sound on/off (updates localStorage)
 */
export function toggleSound(): boolean {
  if (typeof window === 'undefined') return false;

  try {
    const currentState = isSoundEnabled();
    const newState = !currentState;
    localStorage.setItem(SOUND_ENABLED_KEY, String(newState));
    return newState;
  } catch {
    return false;
  }
}

/**
 * Load audio manifest (lazy loaded on first use)
 */
async function loadManifest(): Promise<void> {
  if (audioManifest !== null) return; // Already loaded

  try {
    const response = await fetch('/lib/data/audio-manifest.json');
    if (!response.ok) {
      throw new Error(`Manifest fetch failed: ${response.status}`);
    }
    audioManifest = await response.json();
  } catch (error) {
    console.warn('Audio manifest not found. Audio playback disabled.', error);
    audioManifest = {}; // Empty manifest = no audio available
  }
}

/**
 * Get Howl instance for a character (creates or retrieves from cache)
 */
async function getAudioForCharacter(character: string): Promise<Howl | null> {
  // Ensure manifest is loaded
  await loadManifest();

  if (!audioManifest || !audioManifest[character]) {
    console.warn(`No audio available for character: ${character}`);
    return null;
  }

  // Check cache
  if (audioCache.has(character)) {
    return audioCache.get(character)!;
  }

  // Create new Howl instance
  const { filename } = audioManifest[character];
  const howl = new Howl({
    src: [`/audio/${filename}`],
    preload: true,
    html5: false, // Use Web Audio for better performance
    onloaderror: (id, error) => {
      console.error(`Failed to load audio for ${character}:`, error);
    },
  });

  audioCache.set(character, howl);
  return howl;
}

/**
 * Play pronunciation for a character
 *
 * @param character - The Chinese character to pronounce
 * @param onStart - Optional callback when audio starts playing
 * @param onEnd - Optional callback when audio finishes
 * @returns Promise that resolves when audio completes (or rejects on error)
 */
export async function playCharacterPronunciation(
  character: string,
  onStart?: () => void,
  onEnd?: () => void
): Promise<void> {
  // Check if sound is enabled
  if (!isSoundEnabled()) {
    console.log('Sound disabled by user preference');
    return Promise.resolve();
  }

  try {
    const howl = await getAudioForCharacter(character);

    if (!howl) {
      return Promise.resolve(); // No audio available, fail gracefully
    }

    return new Promise((resolve) => {
      // Set up event handlers
      if (onStart) {
        howl.once('play', onStart);
      }

      howl.once('end', () => {
        if (onEnd) onEnd();
        resolve();
      });

      // Handle errors gracefully
      howl.once('loaderror', () => {
        console.warn(`Audio load error for ${character}`);
        resolve(); // Resolve anyway, don't break UX
      });

      howl.once('playerror', () => {
        console.warn(`Audio play error for ${character}`);
        resolve();
      });

      // Play the audio
      howl.play();
    });
  } catch (error) {
    console.error('Error playing audio:', error);
    return Promise.resolve(); // Fail gracefully
  }
}

/**
 * Preload audio for multiple characters (optimizes UX)
 *
 * @param characters - Array of characters to preload
 */
export async function preloadCharacterAudio(characters: string[]): Promise<void> {
  if (!isSoundEnabled()) return;

  await loadManifest();

  const promises = characters.map((char) => getAudioForCharacter(char));
  await Promise.all(promises);
}

/**
 * Stop all currently playing audio
 */
export function stopAllAudio(): void {
  audioCache.forEach((howl) => {
    howl.stop();
  });
}

/**
 * Clear audio cache (use if memory is a concern)
 */
export function clearAudioCache(): void {
  audioCache.forEach((howl) => {
    howl.unload();
  });
  audioCache.clear();
}

/**
 * Get audio playback statistics (for debugging/monitoring)
 */
export function getAudioStats(): {
  manifestLoaded: boolean;
  totalCharactersAvailable: number;
  cachedAudioCount: number;
} {
  return {
    manifestLoaded: audioManifest !== null,
    totalCharactersAvailable: audioManifest ? Object.keys(audioManifest).length : 0,
    cachedAudioCount: audioCache.size,
  };
}
